# sylar学习07：关于智能指针

先说一下，自己其实是把IO协程调度模块给跳过了。因为自己确实看不太懂协程相关的内容，所以就先跳过这个又和协程相关的模块了，不过自己在末端学到了可以查看协程的ID，这个之后可以应用一下子。

另外自己在项目中的很多地方其实都看到智能指针的身影，因此在这里总结一下吧，感觉不总结确实进行不下去了。

**为什么使用智能指针？**

智能指针是为了防止普通指针出现内存泄漏的情况。如果我们new了一个指针，但是没有进行delete释放，或者在delete之前就以外退出了，会导致内存没有被释放，内存泄漏。当然如果我们用一个普通对象其实是不需要考虑这样的问题的。智能指针就是一种有生命周期的对象，过期之后就会删除指向的内存。

所以智能指针的出现是非常合理的一件事情。

跳过已经被放弃的auto_ptr，现在见的最多的是unique_ptr和share_ptr。

unique_ptr的一些特性：

> 1. 基于排他所有权模式：两个指针不能指向同一个资源
> 2. 无法进行左值unique_ptr复制构造，也无法进行左值复制赋值操作，但允许临时右值赋值构造和赋值
> 3. 保存指向某个对象的指针，当它本身离开作用域时会自动释放它指向的对象。
> 4. 在容器中保存指针是安全的

当然有时我们也需要多个指针变量共享的情况，这时就会用到了shared_ptr。有趣的是，在项目中遇到的智能指针全是这样的模式。我们可以记录引用特定内存对象的智能指针数量，遇到复制或者拷贝时，引用指针计数加一，智能指针析构时，引用计数减1。

同时，智能指针也包括很多的操作：

> **get**() 获取智能指针托管的指针地址。
>
> **release**() 取消智能指针对动态内存的托管，改由管理员进行管理。
>
> **reset**() 重置智能指针托管的内存地址，如果地址不一致，原来的会被析构掉。
>
> 在share_ptr中，还有**use_count**()获得当前托管指针的引用计数，这个自己也看到项目中有了。

总而言之其实最重要的就是我们为什么要用智能指针，且现在可以看出，用智能指针其实指向的是这个结构本身。

结合智能指针学习一下`enable_shared_from_this`。

 std::enable_shared_from_this 能让一个对象（假设其名为 t ，且已被一个 std::shared_ptr 对象 pt 管理）安全地生成其他额外的 std::shared_ptr 实例（假设名为 pt1, pt2, ... ） ，它们与 pt 共享对象 t 的所有权。
       若一个类 T 继承 std::enable_shared_from_this<T> ，则会为该类 T 提供成员函数： shared_from_this 。 当 T 类型对象 t 被一个为名为 pt 的 std::shared_ptr<T> 类对象管理时，调用 T::shared_from_this 成员函数，将会返回一个新的 std::shared_ptr<T> 对象，它与 pt 共享 t 的所有权。

使用场合：

 当类A被share_ptr管理，且在类A的成员函数里需要把当前类对象作为参数传给其他函数时，就需要传递一个指向自身的share_ptr。

1.为何不直接传递this指针

使用智能指针的初衷就是为了方便资源管理，如果在某些地方使用智能指针，某些地方使用原始指针，很容易破坏智能指针的语义，从而产生各种错误。

2.可以直接传递share_ptr<this>么？

答案是不能，因为这样会造成2个非共享的share_ptr指向同一个对象，未增加引用计数导对象被析构两次。

一般的使用情况是这样的：

```c++

struct Good : std::enable_shared_from_this<Good> // 注意：继承
{
public:
	std::shared_ptr<Good> getptr() {
		return shared_from_this();
	}
	~Good() { std::cout << "Good::~Good() called" << std::endl; }
};
```

自己确实也在项目中见到过这样的用法mmm。

为什么会出现这样的使用场合呢：

因为在异步调用中，存在一个保活机制，异步函数执行的时间点我们是无法确定的，然而异步函数可能会使用到异步调用之前就存在的变量。为了保证该变量在异步函数执期间一直有效，我们可以传递一个指向自身的share_ptr给异步函数，这样在异步函数执行期间share_ptr所管理的对象就不会析构，所使用的变量也会一直有效了（保活）。

感觉上是，即使自身的智能指针析构了，但是通过shared_from_this()传递的还没有。这个确实得通过use_count()来看还有几个，怪不得自己之前项目中会看到，但自己还不是很清楚。







参考文章：

[C++ 智能指针 - 全部用法详解-CSDN博客](https://blog.csdn.net/cpp_learner/article/details/118912592)

[C++11新特性之十：enable_shared_from_this_share from this-CSDN博客](https://blog.csdn.net/caoshangpa/article/details/79392878)