# sylar高性能分布式服务器框架学习26：总结一下

这里就是总结一下关于sylar的内容，一个是看一下从sylar中学到了什么，另一个是看如何把这个项目进行拆分，然后写到简历里面。

这个项目一共有这些模块：

日志模块、配置模块、线程模块、协程模块、协程调度模块、IO协程调度模块、定时器模块、hook模块、address模块、序列化模块、socket流接口模块、http模块、HttpServer模块、HttpConnection模块。

(还有一个版本为socket模块、bytearray序列化模块、Tcpserver模块、stream模块、http模块、servlet模块(hook模块之前是一样的))

这些大致分以下类，就是：

1.日志模块、配置模块：一些准备工作。

2.线程模块、协程模块：关于多线程与多进程。

3.协程调度模块、IO协程调度模块、定时器模块：关于调度与IO调度

4.hook模块：这个还不知道该怎么利用

5.序列化模块放到nginx中说

6.address模块、socket流接口模块、http模块、HttpServer模块、HttpConnection模块：http+socket模式。

如果是总结的话，就重新再过一遍吧，把各个类中的关键点，学到了什么汇总一下。这应该是自己最后一遍过了，然后之后就进军nginx了。感觉节奏还是可以的。

### 1.日志/配置模块

这里对应自己写的01，02，03。对应测试文件中的env、log。

日志其实就是输出或者往文件里面添加一些信息，似乎没有很重要的。主要这个模块还是很孤立吧，和其他模块没有什么联动之类的，主要是处理输入输出的，自己也没什么兴趣。

之后是对于命令行，以及配置的处理，对应02和03。

02中主要是对命令行的分析，即args和argv这两个参数。argv这个数组保存的是命令行参数，第一个argv[0]表示的是执行文件的完整路径。

env这里其实就是对于argv的测试，比如我们加入一个-h的命令行参数，然后进行对应的操作这样。

03就是对配置文件的处理，其实这里主要处理的还是字符串的转化，毕竟读入的是字符串，然后到具体的参数这样。

log是对日志的测试，关于读取配置文件，其实每个测试文件都会涉及，这里也没有过多展开。

**总结：**我感觉可能最后会把这部分省略，不再简历中体现，不过可以体现出自己编写了一个完整的服务器这样。



### 2.线程模块、协程模块

这里其实算是很难的部分了，作为后面的后面调度模块的前导内容。

对应04和05。

首先是线程，sylar只有一个进程，即本身，但可以有很多的线程，以及协程。讲到线程就一定得讲到锁了。锁是在mutex中实现的。线程里的用的信号量。

插一句，可以记下来一点原语，这其实很有用的，可以装逼加打分。

所以这里主要涉及的是三个主要操作：pthread_create，线程的创建；pthread_detach，线程的释放；pthread_join，终止线程。

信号量传递的是：sem_wait，来了一个，需要减一；sem_post，走了一个，需要加一。

这里设计的是生成线程后用sem_wait阻塞自己，然后子线程sem_post让主线程工作。

pthread_create中有线程执行函数run，run中会处理子线程的一些，比如命名啊之类的，然后调用回调函数是cb，cb是构造线程的时候传进来的，相当于是子线程借助主线程的cb来操作，这里就是我们真正想让子线程做的内容。

这里的回调函数传入用的bind，C11中的内容，一方面可以将调用对象和参数绑定成一个仿函数，另一方面可以只绑定部分参数，减少可调用对象传入的参数。

gdb调试的时候可以用set scheduler-locking on指令，即只允许当前线程执行。

然后是关于锁的知识。

关于信号量semaphore，主要就是上面提到的sem_post和sem_wait操作，还有就是初始化sem_init和sem_destroy操作。

后面的是互斥锁，读写锁，自旋锁和原子锁。

自旋锁可能会问应用场景，就是应用在不会等很久，频繁切换用事很长的情况下。

原子锁这里可以学一个关键字volatile。表示该变量可能会被异步修改，编译器不会进行优化，每次都从内存中读取变量的值，因为一般情况下可能从寄存器中读取。

然后是关于协程的内容。



协程怎么说呢，其实主要是切换用的。其实经过这里的学习，自己对于协程的理解倒更深刻了些。虽然不是并行的，但可以通过信号或者什么进行沟通(这个之后看一下确认一下)，然后切换。协程内可以很独立完整的完成自己的任务。

协程主要是用来调度的。需要结合后面的内容来进行理解。

协程切换是由用户进行的，将寄存器上下文和栈保存，然后切换回来时进行恢复即可。

这里的协程并不是自己实现的，而是调用的库，用了这几个库函数：makecontext(初始化线程结构)、swapcontext(保存上下文并切换上下文)、getcontext(将当前执行的上下文保存)、setcontext(将当前程序切换到新的context中，不会返回)。

这里setcontext是没有用的，就不考虑了。

这里其实就是swapcontext在主协程和子协程之间的切换，从主协程切换到子协程用的是resume函数，从子协程切换到主协程用的yield函数。

注意如果是在调度中，主协程是指调度主协程，而非主协程，要区分开这两者。

清楚这个过程之后，基本上就没什么问题了。

协程其实和线程的进行过程差不多，线程是先进入pthread_create中的入口函数run，再允许回调函数cb。

协程是我们自主生成的，先生成主协程，因为主协程并没有对应的栈，所以可以理解为在进入子协程之前都是在主协程里面。

然后生成子协程，子协程中就需要回调函数了，这个和线程是一致的。然后会进行切换，即通过resume函数。因为一开始子协程还没有自己要做的事情，所以会进入MainFunc函数中，然后在这个函数中执行回调，即初始化子协程的函数，之后完成真正想做的事情之后就会yield回到主协程中去。

当然会存在说在进行MainFunc中的yield之前就回到主协程了，这时候如果再使用resume进入子协程的话，是会回到上次子协程回到主协程的位置。

ok这其实就是fiber有关的部分了，最主要的还是那几个系统函数吧，makecontext，swapcontext，getcontext，这几个要记住，可以装一下。



### 3.协程调度模块、IO协程调度模块、定时器模块

协程调度其实就是将一个个任务封装成cb/fiber，然后放入调度器中，让调度模块循环运行。其实自己并没有看到分配给哪个线程去做这个地方，其实还是一个线程，然后轮流去做这样。

调度的主要有两部分内容，一部分是我们要加入的部分，可以直接加入，也可以加上定时器之后加入，另一部分是通过epoll来接收到的。

Scheduler::run()很简单，就是从任务队列中循环取，如果有，就拿出来，然后执行这样。任务其实分为两种，一种是cb，即回调函数，另一种是协程。不过对于回调函数，我们会采取封装为协程的方式执行。

然后其实就是第三种情况了，如果队列为空的话，就要调用idle协程，这里其实有两种情况，一种是ok真的没有任务了，另一种是还有任务，可能传输的任务还没有来，也可能是因为设置了定时器，时间还没有到。

进入到idle协程，其实真正想执行的回调是IOManager::idle()。

>调度器无调度任务时会阻塞idle协程上，对IO调度器而言，idle状态应该关注两件事，一是有没有新的调度任务，对应Schduler::schedule()，如果有新的调度任务，那应该立即退出idle状态，并执行对应的任务；二是关注当前注册的所有IO事件有没有触发，如果有触发，那么应该执行IO事件对应的回调函数。
这个函数其实很像epoll_wait，但是这个函数中竟然还调用了epoll_wait，这事闹的...

不过其实也挺契合的，因为epoll_wait需要的就是等待的时间，然后这里就正好借着定时器的等待时间进行epoll_wait。

这段时间过去之后，就有定时器到时间了，我们把这些到时间的定时器对应的回调函数/协程加入到任务队列中去。

然后就是对于epoll中注册的那些操作，这里其实分为两种情况，一种是通过管道传输来的字符串，另一种是需要进行的读写操作。这里的操作其实和任务队列的处理是相同的，区别好是读操作还是写操作之后，同样将要做的放入到任务队列中去。

关于为什么是在IOManager的析构函数中运行，可能是为了等足够久，让注册的IO事件都来这样么。

这里其实最重要的就是对于epoll的理解了。

这个主要是由三个函数组成的。

首先是epoll_create，这个其实很直接，有以下几部分组成：

> 创建eventpoll，并进行初始化。
>
> 创建一个文件描述符fd。
>
> 创建文件，将private_data设置为eventpoll *ep。
>
> 将创建的fd和创建的匿名文件相关联。

然后是epoo_ctl函数，这个函数经常会听到的是注册，即从此之后epoll就会关注这个fd对应的文件是否有IO操作了。

这个也很简单：

> 查找要进行操作的fd是否已经存在了，如果存在，则报错，如果不存在(或存在，与操作相对应)，就执行添加，删除，修改操作。

但其实添加等操作也比较复杂，以添加为例。

这里其实主要就是这里这个地方，epoll_wait甚至没有很难。

首先，我们通过函数ep_ptable_queue_proc连接file和epitem。是如何连接的呢，就是将fd做为等待队列的链表头，然后绑定回调函数ep_poll_callback，即如果fd文件发生变化，就会调用这个函数进行一系列的操作。

这里通过等待队列就可以获得epitem，虽然看上去并不知道是如何获得的，然后将这个epitem加入已经就绪的队列中，然后唤醒epoll_wait。

这里唤醒的就是沉睡的epoll_wait，所以相当于回到了那里跳出for循环，也跳出if，然后进行处理。

然后就是ET和非ET之间的区别了，如果是ET，epitem不会再进入到ready list中去了，除非fd再次发生改变，再调用ep_poll_callback加进去。非ET则会将epitem加入到ready list中，下次epoll_wait时立刻返回，如果这个fd确实没有事件或数据，则空转一次。



### 4.hook模块

这个模块是自己最不知道该如何去用的。在自己的理解中，hook模块相当于是对于已有那些底层函数的包装，来实现这些函数逻辑的同时，可以做一些自己的操作。

这些操作的主要目的是使用同步的接口实现异步的操作。这个主要还是结合manager一起实现的，即用在任务调度中。例如对于依次添加的三个任务sleep(3)、write、read，正常运行时是先被sleep硬控3s，然后write，然后read。这显然十分浪费，因为sleep了3s，更一般的情况应该是等待传输这样的吧，那你一直等，显然不是一个很好的选择。

所以这里就是先加上一个定时器，然后就不管了，因为都说了是一定时间之后才起作用的嘛，然后就执行其他任务去了。

对于write或者read就是更一般的情况了，就进行注册，然后等待，然后让出，一旦来信息了就进行回调。

感觉应该寄了，真的太累了。洗个澡就睡觉吧，自己真的需要好好睡一觉了，在专注睡觉的同时。



首先你看这里的read_io是用在哪里的，可以看到是在accept函数中的，就是在socket编程中的accept函数，所以处理的主要是一些IO操作。然后read_io的目的是通过同步代码转化为异步代码，这里也提供了接口，如果不开启hook，就是同步的，开启了就是异步的。

一开始也试着尝试去运行，但是如果是阻塞态，即需要try again的话，就不再进行了，转而进入了异步的处理。

如果设置了超时时间，即到了多久就不能再等你了，就加入定时器，等到超时时间之后进行返回。如果tinfo失效了，相当于是进行完了，即在超时时间之前完成了，那ok，皆大欢喜，如果还没有失效，说明是在超时时间内没有完成，就很尴尬。

然后就是添加这个事件了，因为在阻塞嘛，说明消息还没有来，所以就添加以下任务，然后就切换协程了。

嗷其实相当于是把这个任务也当作一个调度来进行了，就是通过`iom.schedule(&test_tcp_server);`来添加调度任务，然后iomanager析构的时候，去执行run，去看看这些任务的执行情况。

如果这些任务都没有好，就运行idle函数，然后才是epoll_wait函数在干活。在idle中，因为没事情做，就先检查一下是不是还有定时器呢，即还有什么任务在倒计时这样，如果还有段时间才来，这才去进行epoll_wait，看看在IO上会不会有什么信息来。可以理解为在定时器来之前打发一下时间。

epoll_wait主要就是在睡眠，然后等着被唤醒，被唤醒的话，就是说明就绪队列上有就绪的epitem，然后就对这个进行处理。

然后我们也跳出epoll_wait函数，对这些events进行处理。这些和之前的其实也是对应的，就是当时在do_io的时候addevent了，然后现在通过`fd_ctx->triggerEvent()`进行处理。

当然这里的处理方式也是放入shedule中去，再进行调度。

之前添加的时候`iom->addEvent(fd, (sylar::IOManager::Event)(event))`表示cb为空的，是因为想要返回到这里，即执行当前协程，即通过`goto retry`再回到前面，执行真正的accept函数。



因为这个test和自己预想的差别有点大，所以就运行了一下，发现这个有两个线程。在向schedule添加任务的时候，发现

```c++
void schedule(FiberOrCb fc, int thread = -1) {
        bool need_tickle = false;
        {
            MutexType::Lock lock(m_mutex);
            need_tickle = scheduleNoLock(fc, thread);
        }

        if (need_tickle) {
            tickle(); // 唤醒idle协程
        }
    }
```

而这里的tickle是：

```c++
void IOManager::tickle() {
    SYLAR_LOG_DEBUG(g_logger) << "tickle";
    if(!hasIdleThreads()) {
        return;
    }
    int rt = write(m_tickleFds[1], "T", 1);
    SYLAR_ASSERT(rt == 1);
}
```

这里其实是有另外的空闲线程的话，就发送一个"T"，这个T自己之后再管道传输的时候也看到了，正好可以对应起来。

不过除此之外没有看到其他会应用两个线程的地方。ok目前来看应该就是这样。那就先这样吧，这样的逻辑自己应该都明白了。



先这样吧，感觉hook的大部分内容自己都掌握了。然后就是后面的address相关的内容了。



### 6.address模块、socket流接口模块、http模块、HttpServer模块、HttpConnection模块：http+socket模式。

其实这里的内容很杂很乱，主要是结构的构建吧，关于http请求结构(HttpRequest)和http应答结构(HttpResponse)，HTTP请求解析类(HttpRequestParser)和HTTP相应解析结构体(HttpResponseParser)。这些主要是关于结构的搭建吧。

然后就是`test_http_connection.cc`了，是真正做到了通信。这里提到了三种进行沟通的方法：

> 第一种是通过发送报文，然后收到报文：
>
> ```c++
> conn->sendRequest(req);
> auto rsp = conn->recvResponse();
> ```
>
> 这其实完成了报文的发送与接收，观察函数的调用：
>
> sendRequest->writeFixSize->write->send
>
> 第二种是使用url：
>
> ```c++
> auto r = sylar::http::HttpConnection::DoGet("http://www.midlane.top/wiki/", 300);
> ```
>
> 不过根本是一样的，之后也是转化为报文进行发送的。
>
> 第三种是HttpConnectionPool的方式，即在一个池子里面，这里是用了定时器循环添加的方式：
>
> ```c++
> sylar::http::HttpConnectionPool::ptr pool(new sylar::http::HttpConnectionPool(
>         "www.midlane.top", "", 80, 10, 1000 * 30, 5));
> 
>     sylar::IOManager::GetThis()->addTimer(
>         1000, [pool]() {
>             auto r = pool->doGet("/", 300);
>             std::cout << r->toString() << std::endl;
>         },
>         true);
> ```



不过自己好像发现了最终的test文件，即test_http_server.cc函数，这是自己之前没有发现的。

